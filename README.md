# Development-of-a-network-application-in-C-

## **Сетевые протоколы**
* **TCP** - первичный, гарантирует упорядоченную доставку данных от пользователя к серверу (и наоборот).
* **UDP** - не гарантирует отправку сообщений, доставляет пакеты вразнобой, но бысрее при условии одинакого количества данных.
* **HTTP**-сообщения представляют собой обычный текст, поэтому неавторизованные лица могут легко получить к ним доступ и прочитать их через Интернет.
* **HTTPS** передает все данные в зашифрованном виде.
* **DNS** - не требует установки соединений перед отправкой

 ```C#
    string host = "yandex.ru";
    IPAddress[] addresses = Dns.GetHostAddresses(host, System.Net.Sockets.AddresFamily.InterNetwork);
    Console.Write($"Найдено {addresses.Length} адресов");
    Dictionary<IPAdress, long> pings = new();  
  
   foreach(IPAdress address in addresses) {
        new Thread(() =>
        {
          Ping pingSender = new Ping ();
          PringReply pringReply = ping.Send(address);
          prings.Add(addres, pringReply.Roundtriptime);
         }).Start();
    }
 ```
 Класс **= new Ping ()**
 Позволяет приложению определить, доступен ли удаленный компьютер по сети.
    
  ## **Синхронизация**
  
  Есть два вида синхронизации - односторонняя и двусторонняя в **многопоточности**.  
  Класс **= new Thread(() => Function(x, y))**  
  Позволяет одному потоку передать выполнение другому потоку.  
   ```C#
    // создаем новый поток
  Thread myThread1 = new Thread(Print); 
  Thread myThread2 = new Thread(new ThreadStart(Print));
  Thread myThread3 = new Thread(()=>Console.WriteLine("Hello Threads"));
   
  myThread1.Start();  // запускаем поток myThread1
  myThread2.Start();  // запускаем поток myThread2
  myThread3.Start();  // запускаем поток myThread3
  ```
   Потоки бывают - главные и фоновые.  
   Критическая секция - это блок кода, исполняемы определенным потоком в один момент времени.  
   ThreadPool - многопоточность в процессоре.  
   Thread - один процессор.  
   Необработанное завершение в потоке приведет к завершению приложения.  
   ref не используется в многопоточности.  

  ## **Асинхронность**
  
  Позволяет вынести отдельные задачи из основного потока в специальные асинхронные методы и при этом более экономно использовать потоки.  
  Ключевыми для работы с асинхронными вызовами являются два оператора: **async** - помогает правильно скомпилировать метод и **await** - помогает дождаться выполнения операции и не выполнять код дальше.

```C#
    class Program
{
    async static Task Main(string[] args)
    {
        await PrintAsync();   // вызов асинхронного метода
        Console.WriteLine("Некоторые действия в методе Main");
 
 
        void Print()
        {
            Thread.Sleep(3000);     // имитация продолжительной работы
            Console.WriteLine("Hello METANIT.COM");
        }
 
        // определение асинхронного метода
        async Task PrintAsync()
        {
            Console.WriteLine("Начало метода PrintAsync"); // выполняется синхронно
            await Task.Run(() => Print());                // выполняется асинхронно
            Console.WriteLine("Конец метода PrintAsync");
        }
    }
}
```

# **PLINQ**
По умолчанию все элементы коллекции в LINQ обрабатываются последовательно, но начиная с .NET 4.0 в пространство имен System.Linq был добавлен класс ParallelEnumerable, который инкапсулирует функциональность PLINQ (Parallel LINQ) и позволяет выполнять обращения к коллекции в параллельном режиме.  
Метод **AsParallel()** позволяет распараллелить запрос к источнику данных.  
Метод **ForAll()** выводит данные в том же потоке, в котором они обрабатываются.  

  # **GOF**
Gang of Four – «Банда четырех» – относится к четырем авторам, написавшим книгу «Design Patterns: Elements of Reusable Object-Oriented Software», в которой они предложили 23 шаблона проектирования, основанные на принципах объектно-ориентированного программирования.
Шаблоны проектирования:

1. Порождающие шаблоны позволяют создать экземпляр какого-либо класса (создать компонент), скрывая при этом логику его создания.

2. Структурные шаблоны помогают эффективно определять отношения между классами (компонентами).

3. Поведенческие шаблоны обеспечивают взаимодействие между компонентами.

# **Entity framework**
Это решение для работы с базами данных, которое используется в программировании на языках семейства .NET. Оно позволяет взаимодействовать с СУБД с помощью сущностей (entity), а не таблиц. Также код с использованием EF пишется гораздо быстрее.  
Подключить Entity Framework можно к любому проекту — от Xamarin до ASP.NET.  
Для начала создайте проект Console Application в Visual Studio. Затем откройте менеджер пакетов NuGet и  скачайте пакет с этим фреймворком. Когда он установится, нужно подключиться к СУБД. Это делается с помощью файла конфигурации.  

Подход **Code-First**, который впервые появился в Entity Framework 4.1, обычно используется, когда у вас есть уже существующее приложение, содержащее модель данных. Эта модель, как правило, описывается с помощью нескольких классов и кода взаимодействия между этими классами. Например, вы можете создать класс по имени Customer, который будет содержать данные покупателя в интернет-магазине:
```C#
public class Customer
{
    // Определить поля, которые используются в базе данных
    public int CustomerId { get; set; }
    public string FirstName { get; set; }
    public string LastName { get; set; }
    public string City { get; set; }
    public int Age { get; set; }
    public DateTime BirthDate { get; set; }
```

При проектировании приложений с подходом **Code-First**, вы сначала создаете классы модели данных не обращая никакого внимания на Entity Framework. После того, как вам понадобилось работать с базой данных, вы используете различные инструменты, которые проецируют структуру базы данных из созданной модели классов. После этого вы можете вернуться к этой модели в коде и, например, изменить ее. Эти изменения затем можно будет отразить в базе данных используя все те же инструменты.
```C#
namespace ProfessorWeb.EntityFramework
{
    public class PwContext : DbContext
    {
        // Это свойство ссылается на таблицу в базе данных
        public DbSet<Customer> Customer { get; set; }
    }
}
```
